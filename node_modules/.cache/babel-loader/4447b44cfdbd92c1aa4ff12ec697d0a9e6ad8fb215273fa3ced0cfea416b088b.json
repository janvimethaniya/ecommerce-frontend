{"ast":null,"code":"import { HTMLProjectionNode } from '../projection/node/HTMLProjectionNode.mjs';\nimport { HTMLVisualElement } from '../render/html/HTMLVisualElement.mjs';\nimport { nodeGroup } from '../projection/node/group.mjs';\nimport { getLayoutId } from './get-layout-elements.mjs';\nimport { addScaleCorrector } from '../projection/styles/scale-correction.mjs';\nimport { correctBorderRadius } from '../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../projection/styles/scale-box-shadow.mjs';\nlet scaleCorrectorAdded = false;\n/**\n * Track active projection nodes per element to handle animation interruption.\n * When a new animation starts on an element that already has an active animation,\n * we need to stop the old animation so the new one can start from the current\n * visual position.\n */\nconst activeProjectionNodes = new WeakMap();\nfunction ensureScaleCorrectors() {\n  if (scaleCorrectorAdded) return;\n  scaleCorrectorAdded = true;\n  addScaleCorrector({\n    borderRadius: {\n      ...correctBorderRadius,\n      applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow\n  });\n}\n/**\n * Get DOM depth of an element\n */\nfunction getDepth(element) {\n  let depth = 0;\n  let current = element.parentElement;\n  while (current) {\n    depth++;\n    current = current.parentElement;\n  }\n  return depth;\n}\n/**\n * Find the closest projection parent for an element\n */\nfunction findProjectionParent(element, nodeCache) {\n  let parent = element.parentElement;\n  while (parent) {\n    const node = nodeCache.get(parent);\n    if (node) return node;\n    parent = parent.parentElement;\n  }\n  return undefined;\n}\n/**\n * Create or reuse a projection node for an element\n */\nfunction createProjectionNode(element, parent, options, transition) {\n  // Check for existing active node - reuse it to preserve animation state\n  const existingNode = activeProjectionNodes.get(element);\n  if (existingNode) {\n    const visualElement = existingNode.options.visualElement;\n    // Update transition options for the new animation\n    const nodeTransition = transition ? {\n      duration: transition.duration,\n      ease: transition.ease\n    } : {\n      duration: 0.3,\n      ease: \"easeOut\"\n    };\n    existingNode.setOptions({\n      ...existingNode.options,\n      animate: true,\n      transition: nodeTransition,\n      ...options\n    });\n    // Re-mount the node if it was previously unmounted\n    // This re-adds it to root.nodes so didUpdate() will process it\n    if (!existingNode.instance) {\n      existingNode.mount(element);\n    }\n    return {\n      node: existingNode,\n      visualElement\n    };\n  }\n  // No existing node - create a new one\n  const latestValues = {};\n  const visualElement = new HTMLVisualElement({\n    visualState: {\n      latestValues,\n      renderState: {\n        transformOrigin: {},\n        transform: {},\n        style: {},\n        vars: {}\n      }\n    },\n    presenceContext: null,\n    props: {}\n  });\n  const node = new HTMLProjectionNode(latestValues, parent);\n  // Convert AnimationOptions to transition format for the projection system\n  const nodeTransition = transition ? {\n    duration: transition.duration,\n    ease: transition.ease\n  } : {\n    duration: 0.3,\n    ease: \"easeOut\"\n  };\n  node.setOptions({\n    visualElement,\n    layout: true,\n    animate: true,\n    transition: nodeTransition,\n    ...options\n  });\n  node.mount(element);\n  visualElement.projection = node;\n  // Track this node as the active one for this element\n  activeProjectionNodes.set(element, node);\n  return {\n    node,\n    visualElement\n  };\n}\n/**\n * Build a projection tree from a list of elements\n */\nfunction buildProjectionTree(elements, existingContext, options) {\n  ensureScaleCorrectors();\n  const nodes = existingContext?.nodes ?? new Map();\n  const visualElements = existingContext?.visualElements ?? new Map();\n  const group = existingContext?.group ?? nodeGroup();\n  const defaultTransition = options?.defaultTransition;\n  const sharedTransitions = options?.sharedTransitions;\n  // Sort elements by DOM depth (parents before children)\n  const sorted = [...elements].sort((a, b) => getDepth(a) - getDepth(b));\n  let root = existingContext?.root;\n  for (const element of sorted) {\n    // Skip if already has a node\n    if (nodes.has(element)) continue;\n    const parent = findProjectionParent(element, nodes);\n    const layoutId = getLayoutId(element);\n    const layoutMode = element.getAttribute(\"data-layout\");\n    const nodeOptions = {\n      layoutId: layoutId ?? undefined,\n      animationType: parseLayoutMode(layoutMode)\n    };\n    // Use layoutId-specific transition if available, otherwise use default\n    const transition = layoutId && sharedTransitions?.get(layoutId) ? sharedTransitions.get(layoutId) : defaultTransition;\n    const {\n      node,\n      visualElement\n    } = createProjectionNode(element, parent, nodeOptions, transition);\n    nodes.set(element, node);\n    visualElements.set(element, visualElement);\n    group.add(node);\n    if (!root) {\n      root = node.root;\n    }\n  }\n  return {\n    nodes,\n    visualElements,\n    group,\n    root: root\n  };\n}\n/**\n * Parse the data-layout attribute value\n */\nfunction parseLayoutMode(value) {\n  if (value === \"position\") return \"position\";\n  if (value === \"size\") return \"size\";\n  if (value === \"preserve-aspect\") return \"preserve-aspect\";\n  return \"both\";\n}\n/**\n * Clean up projection nodes for specific elements.\n * If elementsToCleanup is provided, only those elements are cleaned up.\n * If not provided, all nodes are cleaned up.\n *\n * This allows persisting elements to keep their nodes between animations,\n * matching React's behavior where nodes persist for elements that remain in the DOM.\n */\nfunction cleanupProjectionTree(context, elementsToCleanup) {\n  const elementsToProcess = elementsToCleanup ? [...context.nodes.entries()].filter(([el]) => elementsToCleanup.has(el)) : [...context.nodes.entries()];\n  for (const [element, node] of elementsToProcess) {\n    context.group.remove(node);\n    node.unmount();\n    // Only clear from activeProjectionNodes if this is still the active node.\n    // A newer animation might have already taken over.\n    if (activeProjectionNodes.get(element) === node) {\n      activeProjectionNodes.delete(element);\n    }\n    context.nodes.delete(element);\n    context.visualElements.delete(element);\n  }\n}\nexport { buildProjectionTree, cleanupProjectionTree };","map":{"version":3,"names":["scaleCorrectorAdded","activeProjectionNodes","WeakMap","ensureScaleCorrectors","addScaleCorrector","borderRadius","correctBorderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow","correctBoxShadow","getDepth","element","depth","current","parentElement","findProjectionParent","nodeCache","parent","node","get","undefined","createProjectionNode","options","transition","existingNode","visualElement","nodeTransition","duration","ease","setOptions","animate","instance","mount","latestValues","HTMLVisualElement","visualState","renderState","transformOrigin","transform","style","vars","presenceContext","props","HTMLProjectionNode","layout","projection","set","buildProjectionTree","elements","existingContext","nodes","Map","visualElements","group","nodeGroup","defaultTransition","sharedTransitions","sorted","sort","a","b","root","has","layoutId","getLayoutId","layoutMode","getAttribute","nodeOptions","animationType","parseLayoutMode","add","value","cleanupProjectionTree","context","elementsToCleanup","elementsToProcess","entries","filter","el","remove","unmount","delete"],"sources":["D:\\new mern stack\\react\\project4\\ecommerce\\node_modules\\motion-dom\\src\\layout\\projection-tree.ts"],"sourcesContent":["import type { AnimationOptions } from \"../animation/types\"\nimport type {\n    IProjectionNode,\n    ProjectionNodeOptions,\n} from \"../projection/node/types\"\nimport { HTMLProjectionNode } from \"../projection/node/HTMLProjectionNode\"\nimport { HTMLVisualElement } from \"../render/html/HTMLVisualElement\"\nimport { nodeGroup, type NodeGroup } from \"../projection/node/group\"\nimport { getLayoutId } from \"./get-layout-elements\"\nimport { addScaleCorrector } from \"../render/utils/is-forced-motion-value\"\nimport { correctBorderRadius } from \"../projection/styles/scale-border-radius\"\nimport { correctBoxShadow } from \"../projection/styles/scale-box-shadow\"\n\nlet scaleCorrectorAdded = false\n\n/**\n * Track active projection nodes per element to handle animation interruption.\n * When a new animation starts on an element that already has an active animation,\n * we need to stop the old animation so the new one can start from the current\n * visual position.\n */\nconst activeProjectionNodes = new WeakMap<HTMLElement, IProjectionNode>()\n\nfunction ensureScaleCorrectors() {\n    if (scaleCorrectorAdded) return\n    scaleCorrectorAdded = true\n\n    addScaleCorrector({\n        borderRadius: {\n            ...correctBorderRadius,\n            applyTo: [\n                \"borderTopLeftRadius\",\n                \"borderTopRightRadius\",\n                \"borderBottomLeftRadius\",\n                \"borderBottomRightRadius\",\n            ],\n        },\n        borderTopLeftRadius: correctBorderRadius,\n        borderTopRightRadius: correctBorderRadius,\n        borderBottomLeftRadius: correctBorderRadius,\n        borderBottomRightRadius: correctBorderRadius,\n        boxShadow: correctBoxShadow,\n    })\n}\n\nexport interface ProjectionContext {\n    nodes: Map<HTMLElement, IProjectionNode>\n    visualElements: Map<HTMLElement, HTMLVisualElement>\n    group: NodeGroup\n    root: IProjectionNode\n}\n\n/**\n * Get DOM depth of an element\n */\nfunction getDepth(element: Element): number {\n    let depth = 0\n    let current = element.parentElement\n    while (current) {\n        depth++\n        current = current.parentElement\n    }\n    return depth\n}\n\n/**\n * Find the closest projection parent for an element\n */\nfunction findProjectionParent(\n    element: HTMLElement,\n    nodeCache: Map<HTMLElement, IProjectionNode>\n): IProjectionNode | undefined {\n    let parent = element.parentElement as HTMLElement | null\n    while (parent) {\n        const node = nodeCache.get(parent)\n        if (node) return node\n        parent = parent.parentElement as HTMLElement | null\n    }\n    return undefined\n}\n\n/**\n * Create or reuse a projection node for an element\n */\nfunction createProjectionNode(\n    element: HTMLElement,\n    parent: IProjectionNode | undefined,\n    options: ProjectionNodeOptions,\n    transition?: AnimationOptions\n): { node: IProjectionNode; visualElement: HTMLVisualElement } {\n    // Check for existing active node - reuse it to preserve animation state\n    const existingNode = activeProjectionNodes.get(element)\n    if (existingNode) {\n        const visualElement = existingNode.options.visualElement as HTMLVisualElement\n\n        // Update transition options for the new animation\n        const nodeTransition = transition\n            ? { duration: transition.duration, ease: transition.ease as any }\n            : { duration: 0.3, ease: \"easeOut\" }\n\n        existingNode.setOptions({\n            ...existingNode.options,\n            animate: true,\n            transition: nodeTransition,\n            ...options,\n        })\n\n        // Re-mount the node if it was previously unmounted\n        // This re-adds it to root.nodes so didUpdate() will process it\n        if (!existingNode.instance) {\n            existingNode.mount(element)\n        }\n\n        return { node: existingNode, visualElement }\n    }\n\n    // No existing node - create a new one\n    const latestValues: Record<string, any> = {}\n\n    const visualElement = new HTMLVisualElement({\n        visualState: {\n            latestValues,\n            renderState: {\n                transformOrigin: {},\n                transform: {},\n                style: {},\n                vars: {},\n            },\n        },\n        presenceContext: null,\n        props: {},\n    })\n\n    const node = new HTMLProjectionNode(latestValues, parent)\n\n    // Convert AnimationOptions to transition format for the projection system\n    const nodeTransition = transition\n        ? { duration: transition.duration, ease: transition.ease as any }\n        : { duration: 0.3, ease: \"easeOut\" }\n\n    node.setOptions({\n        visualElement,\n        layout: true,\n        animate: true,\n        transition: nodeTransition,\n        ...options,\n    })\n\n    node.mount(element)\n    visualElement.projection = node\n\n    // Track this node as the active one for this element\n    activeProjectionNodes.set(element, node)\n\n    return { node, visualElement }\n}\n\nexport interface BuildProjectionTreeOptions {\n    defaultTransition?: AnimationOptions\n    sharedTransitions?: Map<string, AnimationOptions>\n}\n\n/**\n * Build a projection tree from a list of elements\n */\nexport function buildProjectionTree(\n    elements: HTMLElement[],\n    existingContext?: ProjectionContext,\n    options?: BuildProjectionTreeOptions\n): ProjectionContext {\n    ensureScaleCorrectors()\n\n    const nodes = existingContext?.nodes ?? new Map<HTMLElement, IProjectionNode>()\n    const visualElements =\n        existingContext?.visualElements ?? new Map<HTMLElement, HTMLVisualElement>()\n    const group = existingContext?.group ?? nodeGroup()\n\n    const defaultTransition = options?.defaultTransition\n    const sharedTransitions = options?.sharedTransitions\n\n    // Sort elements by DOM depth (parents before children)\n    const sorted = [...elements].sort((a, b) => getDepth(a) - getDepth(b))\n\n    let root: IProjectionNode | undefined = existingContext?.root\n\n    for (const element of sorted) {\n        // Skip if already has a node\n        if (nodes.has(element)) continue\n\n        const parent = findProjectionParent(element, nodes)\n        const layoutId = getLayoutId(element)\n        const layoutMode = element.getAttribute(\"data-layout\")\n\n        const nodeOptions: ProjectionNodeOptions = {\n            layoutId: layoutId ?? undefined,\n            animationType: parseLayoutMode(layoutMode),\n        }\n\n        // Use layoutId-specific transition if available, otherwise use default\n        const transition = layoutId && sharedTransitions?.get(layoutId)\n            ? sharedTransitions.get(layoutId)\n            : defaultTransition\n\n        const { node, visualElement } = createProjectionNode(\n            element,\n            parent,\n            nodeOptions,\n            transition\n        )\n\n        nodes.set(element, node)\n        visualElements.set(element, visualElement)\n        group.add(node)\n\n        if (!root) {\n            root = node.root\n        }\n    }\n\n    return {\n        nodes,\n        visualElements,\n        group,\n        root: root!,\n    }\n}\n\n/**\n * Parse the data-layout attribute value\n */\nfunction parseLayoutMode(\n    value: string | null\n): \"size\" | \"position\" | \"both\" | \"preserve-aspect\" {\n    if (value === \"position\") return \"position\"\n    if (value === \"size\") return \"size\"\n    if (value === \"preserve-aspect\") return \"preserve-aspect\"\n    return \"both\"\n}\n\n/**\n * Clean up projection nodes for specific elements.\n * If elementsToCleanup is provided, only those elements are cleaned up.\n * If not provided, all nodes are cleaned up.\n *\n * This allows persisting elements to keep their nodes between animations,\n * matching React's behavior where nodes persist for elements that remain in the DOM.\n */\nexport function cleanupProjectionTree(\n    context: ProjectionContext,\n    elementsToCleanup?: Set<HTMLElement>\n) {\n    const elementsToProcess = elementsToCleanup\n        ? [...context.nodes.entries()].filter(([el]) => elementsToCleanup.has(el))\n        : [...context.nodes.entries()]\n\n    for (const [element, node] of elementsToProcess) {\n        context.group.remove(node)\n        node.unmount()\n\n        // Only clear from activeProjectionNodes if this is still the active node.\n        // A newer animation might have already taken over.\n        if (activeProjectionNodes.get(element) === node) {\n            activeProjectionNodes.delete(element)\n        }\n\n        context.nodes.delete(element)\n        context.visualElements.delete(element)\n    }\n}\n\n/**\n * Set a value on a projection node's visual element\n */\nexport function setNodeValue(\n    context: ProjectionContext,\n    element: HTMLElement,\n    key: string,\n    value: any\n) {\n    const visualElement = context.visualElements.get(element)\n    if (visualElement) {\n        visualElement.latestValues[key] = value\n        visualElement.scheduleRender()\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}