{"ast":null,"code":"import { noop } from 'motion-utils';\nimport { GroupAnimation } from '../animation/GroupAnimation.mjs';\nimport { getLayoutElements } from './get-layout-elements.mjs';\nimport { buildProjectionTree, cleanupProjectionTree } from './projection-tree.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\nimport { frame } from '../frameloop/frame.mjs';\nclass LayoutAnimationBuilder {\n  constructor(scope, updateDom, defaultOptions) {\n    this.sharedTransitions = new Map();\n    this.notifyReady = noop;\n    this.executed = false;\n    this.scope = scope;\n    this.updateDom = updateDom;\n    this.defaultOptions = defaultOptions;\n    this.readyPromise = new Promise(resolve => {\n      this.notifyReady = resolve;\n    });\n    // Queue execution on microtask to allow builder methods to be called\n    queueMicrotask(() => this.execute());\n  }\n  shared(id, options) {\n    this.sharedTransitions.set(id, options);\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    return this.readyPromise.then(onfulfilled, onrejected);\n  }\n  async execute() {\n    if (this.executed) return;\n    this.executed = true;\n    let context;\n    // Phase 1: Pre-mutation - Build projection tree and take snapshots\n    const beforeElements = getLayoutElements(this.scope);\n    if (beforeElements.length > 0) {\n      context = buildProjectionTree(beforeElements, undefined, this.getBuildOptions());\n      context.root.startUpdate();\n      for (const node of context.nodes.values()) {\n        node.isLayoutDirty = false;\n        node.willUpdate();\n      }\n    }\n    // Phase 2: Execute DOM update\n    this.updateDom();\n    // Phase 3: Post-mutation - Compare before/after elements\n    const afterElements = getLayoutElements(this.scope);\n    const beforeSet = new Set(beforeElements);\n    const afterSet = new Set(afterElements);\n    const entering = afterElements.filter(el => !beforeSet.has(el));\n    const exiting = beforeElements.filter(el => !afterSet.has(el));\n    // Build projection nodes for entering elements\n    if (entering.length > 0) {\n      context = buildProjectionTree(entering, context, this.getBuildOptions());\n    }\n    // No layout elements - return empty animation\n    if (!context) {\n      this.notifyReady(new GroupAnimation([]));\n      return;\n    }\n    // Handle shared elements\n    for (const element of exiting) {\n      const node = context.nodes.get(element);\n      node?.getStack()?.remove(node);\n    }\n    for (const element of entering) {\n      context.nodes.get(element)?.promote();\n    }\n    // Phase 4: Animate\n    context.root.didUpdate();\n    await new Promise(resolve => frame.postRender(() => resolve()));\n    const animations = [];\n    for (const node of context.nodes.values()) {\n      if (node.currentAnimation) {\n        animations.push(node.currentAnimation);\n      }\n    }\n    const groupAnimation = new GroupAnimation(animations);\n    groupAnimation.finished.then(() => {\n      // Only clean up nodes for elements no longer in the document.\n      // Elements still in DOM keep their nodes so subsequent animations\n      // can use the stored position snapshots (A→B→A pattern).\n      const elementsToCleanup = new Set();\n      for (const element of context.nodes.keys()) {\n        if (!document.contains(element)) {\n          elementsToCleanup.add(element);\n        }\n      }\n      cleanupProjectionTree(context, elementsToCleanup);\n    });\n    this.notifyReady(groupAnimation);\n  }\n  getBuildOptions() {\n    return {\n      defaultTransition: this.defaultOptions || {\n        duration: 0.3,\n        ease: \"easeOut\"\n      },\n      sharedTransitions: this.sharedTransitions.size > 0 ? this.sharedTransitions : undefined\n    };\n  }\n}\n/**\n * Parse arguments for animateLayout overloads\n */\nfunction parseAnimateLayoutArgs(scopeOrUpdateDom, updateDomOrOptions, options) {\n  // animateLayout(updateDom)\n  if (typeof scopeOrUpdateDom === \"function\") {\n    return {\n      scope: document,\n      updateDom: scopeOrUpdateDom,\n      defaultOptions: updateDomOrOptions\n    };\n  }\n  // animateLayout(scope, updateDom, options?)\n  const elements = resolveElements(scopeOrUpdateDom);\n  const scope = elements[0] || document;\n  return {\n    scope: scope instanceof Document ? scope : scope,\n    updateDom: updateDomOrOptions,\n    defaultOptions: options\n  };\n}\nexport { LayoutAnimationBuilder, parseAnimateLayoutArgs };","map":{"version":3,"names":["LayoutAnimationBuilder","constructor","scope","updateDom","defaultOptions","sharedTransitions","Map","notifyReady","noop","executed","readyPromise","Promise","resolve","queueMicrotask","execute","shared","id","options","set","then","onfulfilled","onrejected","context","beforeElements","getLayoutElements","length","buildProjectionTree","undefined","getBuildOptions","root","startUpdate","node","nodes","values","isLayoutDirty","willUpdate","afterElements","beforeSet","Set","afterSet","entering","filter","el","has","exiting","GroupAnimation","element","get","getStack","remove","promote","didUpdate","frame","postRender","animations","currentAnimation","push","groupAnimation","finished","elementsToCleanup","keys","document","contains","add","cleanupProjectionTree","defaultTransition","duration","ease","size","parseAnimateLayoutArgs","scopeOrUpdateDom","updateDomOrOptions","elements","resolveElements","Document"],"sources":["D:\\new mern stack\\react\\project4\\ecommerce\\node_modules\\motion-dom\\src\\layout\\LayoutAnimationBuilder.ts"],"sourcesContent":["import { noop } from \"motion-utils\"\nimport type { AnimationOptions } from \"../animation/types\"\nimport { GroupAnimation, type AcceptedAnimations } from \"../animation/GroupAnimation\"\nimport { getLayoutElements } from \"./get-layout-elements\"\nimport {\n    buildProjectionTree,\n    cleanupProjectionTree,\n    type ProjectionContext,\n    type BuildProjectionTreeOptions,\n} from \"./projection-tree\"\nimport { resolveElements, type ElementOrSelector } from \"../utils/resolve-elements\"\nimport { frame } from \"../frameloop\"\n\nexport class LayoutAnimationBuilder implements PromiseLike<GroupAnimation> {\n    private scope: Element | Document\n    private updateDom: () => void\n    private defaultOptions?: AnimationOptions\n\n    private sharedTransitions = new Map<string, AnimationOptions>()\n\n    private notifyReady: (value: GroupAnimation) => void = noop\n    private readyPromise: Promise<GroupAnimation>\n    private executed = false\n\n    constructor(\n        scope: Element | Document,\n        updateDom: () => void,\n        defaultOptions?: AnimationOptions\n    ) {\n        this.scope = scope\n        this.updateDom = updateDom\n        this.defaultOptions = defaultOptions\n\n        this.readyPromise = new Promise<GroupAnimation>((resolve) => {\n            this.notifyReady = resolve\n        })\n\n        // Queue execution on microtask to allow builder methods to be called\n        queueMicrotask(() => this.execute())\n    }\n\n    shared(id: string, options: AnimationOptions): this {\n        this.sharedTransitions.set(id, options)\n        return this\n    }\n\n    then<TResult1 = GroupAnimation, TResult2 = never>(\n        onfulfilled?:\n            | ((value: GroupAnimation) => TResult1 | PromiseLike<TResult1>)\n            | null,\n        onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n    ): Promise<TResult1 | TResult2> {\n        return this.readyPromise.then(onfulfilled, onrejected)\n    }\n\n    private async execute() {\n        if (this.executed) return\n        this.executed = true\n\n        let context: ProjectionContext | undefined\n\n        // Phase 1: Pre-mutation - Build projection tree and take snapshots\n        const beforeElements = getLayoutElements(this.scope)\n\n        if (beforeElements.length > 0) {\n            context = buildProjectionTree(\n                beforeElements,\n                undefined,\n                this.getBuildOptions()\n            )\n\n            context.root.startUpdate()\n\n            for (const node of context.nodes.values()) {\n                node.isLayoutDirty = false\n                node.willUpdate()\n            }\n        }\n\n        // Phase 2: Execute DOM update\n        this.updateDom()\n\n        // Phase 3: Post-mutation - Compare before/after elements\n        const afterElements = getLayoutElements(this.scope)\n        const beforeSet = new Set(beforeElements)\n        const afterSet = new Set(afterElements)\n\n        const entering = afterElements.filter((el) => !beforeSet.has(el))\n        const exiting = beforeElements.filter((el) => !afterSet.has(el))\n\n        // Build projection nodes for entering elements\n        if (entering.length > 0) {\n            context = buildProjectionTree(\n                entering,\n                context,\n                this.getBuildOptions()\n            )\n        }\n\n        // No layout elements - return empty animation\n        if (!context) {\n            this.notifyReady(new GroupAnimation([]))\n            return\n        }\n\n        // Handle shared elements\n        for (const element of exiting) {\n            const node = context.nodes.get(element)\n            node?.getStack()?.remove(node)\n        }\n\n        for (const element of entering) {\n            context.nodes.get(element)?.promote()\n        }\n\n        // Phase 4: Animate\n        context.root.didUpdate()\n\n        await new Promise<void>((resolve) =>\n            frame.postRender(() => resolve())\n        )\n\n        const animations: AcceptedAnimations[] = []\n        for (const node of context.nodes.values()) {\n            if (node.currentAnimation) {\n                animations.push(node.currentAnimation)\n            }\n        }\n\n        const groupAnimation = new GroupAnimation(animations)\n\n        groupAnimation.finished.then(() => {\n            // Only clean up nodes for elements no longer in the document.\n            // Elements still in DOM keep their nodes so subsequent animations\n            // can use the stored position snapshots (A→B→A pattern).\n            const elementsToCleanup = new Set<HTMLElement>()\n            for (const element of context!.nodes.keys()) {\n                if (!document.contains(element)) {\n                    elementsToCleanup.add(element)\n                }\n            }\n            cleanupProjectionTree(context!, elementsToCleanup)\n        })\n\n        this.notifyReady(groupAnimation)\n    }\n\n    private getBuildOptions(): BuildProjectionTreeOptions {\n        return {\n            defaultTransition: this.defaultOptions || {\n                duration: 0.3,\n                ease: \"easeOut\",\n            },\n            sharedTransitions:\n                this.sharedTransitions.size > 0\n                    ? this.sharedTransitions\n                    : undefined,\n        }\n    }\n\n}\n\n/**\n * Parse arguments for animateLayout overloads\n */\nexport function parseAnimateLayoutArgs(\n    scopeOrUpdateDom: ElementOrSelector | (() => void),\n    updateDomOrOptions?: (() => void) | AnimationOptions,\n    options?: AnimationOptions\n): {\n    scope: Element | Document\n    updateDom: () => void\n    defaultOptions?: AnimationOptions\n} {\n    // animateLayout(updateDom)\n    if (typeof scopeOrUpdateDom === \"function\") {\n        return {\n            scope: document,\n            updateDom: scopeOrUpdateDom,\n            defaultOptions: updateDomOrOptions as AnimationOptions | undefined,\n        }\n    }\n\n    // animateLayout(scope, updateDom, options?)\n    const elements = resolveElements(scopeOrUpdateDom)\n    const scope = elements[0] || document\n\n    return {\n        scope: scope instanceof Document ? scope : scope,\n        updateDom: updateDomOrOptions as () => void,\n        defaultOptions: options,\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}